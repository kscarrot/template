---
alwaysApply: true
---

# 开发指南

## 理念

### 核心信念

- **渐进式进展，而非一步到位** - 进行可编译且能通过测试的小幅变更。
- **从现有代码中学习** - 在实现前先研究和规划。
- **务实优于教条** - 适应项目的实际情况。
- **清晰的意图优于巧妙的代码** - 保持朴素和直观。

### 简洁意味着

- 每个函数/类只负责单一职责。
- 避免过早抽象。
- 不用花哨的技巧 — 选择朴素的解决方案。
- 如果需要解释，说明它太复杂了。

## 流程

### 1. 规划与分阶段 (Planning & Staging)

将复杂的工作分解成 3-5 个阶段，并记录在 `IMPLEMENTATION_PLAN.md` 中：

```markdown
## 阶段 N：[名称]

**目标**：[具体的交付物]
**成功标准**：[可测试的产出]
**测试**：[具体的测试用例]
**状态**：[未开始|进行中|已完成]
```

- 随着进度更新状态。
- 所有阶段完成后删除该文件。

### 2. 实现流程

1.  **理解** - 研究代码库中的现有模式。
2.  **测试** - 先写测试 (红灯)。
3.  **实现** - 用最少的代码让测试通过 (绿灯)。
4.  **重构** - 在测试通过的前提下清理代码。
5.  **提交 (Commit)** - 撰写清晰的提交信息，并链接到规划文件。

### 3. 遇到困难时 (尝试 3 次后)

**重要**：每个问题最多尝试 3 次，然后停下来。

1.  **记录失败的内容**：

    - 你尝试了什么。
    - 具体的错误信息。
    - 你认为失败的原因。

2.  **研究替代方案**：

    - 找出 2-3 个类似的实现。
    - 记录它们使用的不同方法。

3.  **质询基本原则**：

    - 这是一个正确的抽象层级吗？
    - 这个问题可以分解成更小的问题吗？
    - 有没有一个完全更简单的方法？

4.  **从不同角度尝试**：

    - 使用不同的库/框架功能？
    - 采用不同的架构模式？
    - 移除而非增加抽象层？

## 技术标准

### 架构原则

- **组合优于继承** - 使用依赖注入。
- **接口优于单例** - 以便于测试和保证灵活性。
- **显式优于隐式** - 保持清晰的数据流和依赖关系。
- **尽可能测试驱动** - 绝不禁用测试，而是修复它们。

### 代码质量

- **每次提交 (commit) 都必须**：

  - 成功编译。
  - 通过所有现有测试。
  - 包含新功能的测试。
  - 遵循项目的格式化/Linter 规范。

- **提交前**：

  - 运行格式化工具/Linter。
  - 自我审查变更。
  - 确保提交信息解释了"为什么"(why)。

### 错误处理

- 快速失败，并提供描述性信息。
- 包含用于调试的上下文信息。
- 在适当的层级处理错误。
- 绝不静默地处理异常。

## 决策框架

当存在多种有效方法时，应按以下顺序选择：

1.  **可测试性** - 我能轻易地测试它吗？
2.  **可读性** - 6 个月后还有人能看懂吗？
3.  **一致性** - 这是否符合项目的既有模式？
4.  **简洁性** - 这是能解决问题的最简单的方案吗？
5.  **可逆性** - 未来修改的难度有多大？

## 项目集成

### 学习代码库

- 找出 3 个类似的功能/组件。
- 识别出通用的模式和约定。
- 尽可能使用相同的库/工具类。
- 遵循现有的测试模式。

### 工具集

- 使用项目现有的构建系统。
- 使用项目现有的测试框架。
- 使用项目现有的格式化工具/Linter 配置。
- 没有充分的理由，不要引入新工具。

## 质量门禁

### "完成"的定义

- [ ] 已编写测试并全部通过
- [ ] 代码遵循项目约定
- [ ] 没有 Linter/格式化工具的警告
- [ ] 提交信息清晰明确
- [ ] 实现内容与规划相符
- [ ] 没有未关联 issue 编号的 TODO 项

### 测试指南

- 测试行为，而非实现细节。
- 尽可能每个测试只包含一个断言 (assertion)。
- 测试名称应清晰描述测试场景。
- 使用现有的测试工具/辅助函数。
- 测试应具有确定性。

## 重要提醒

**绝不**：

- 使用 `--no-verify` 绕过提交钩子 (commit hooks)。
- 禁用测试而不是修复它们。
- 提交无法编译的代码。
- 做出假设 — 应通过现有代码进行验证。

**务必**：

- 渐进式地提交可工作的代码。
- 随时更新规划文件。
- 从现有的实现中学习。
- 尝试 3 次失败后就停下来重新评估。
# 开发指南

## 理念

### 核心信念

- **渐进式进展，而非一步到位** - 进行可编译且能通过测试的小幅变更。
- **从现有代码中学习** - 在实现前先研究和规划。
- **务实优于教条** - 适应项目的实际情况。
- **清晰的意图优于巧妙的代码** - 保持朴素和直观。

### 简洁意味着

- 每个函数/类只负责单一职责。
- 避免过早抽象。
- 不用花哨的技巧 — 选择朴素的解决方案。
- 如果需要解释，说明它太复杂了。

## 流程

### 1. 规划与分阶段 (Planning & Staging)

将复杂的工作分解成 3-5 个阶段，并记录在 `IMPLEMENTATION_PLAN.md` 中：

```markdown
## 阶段 N：[名称]

**目标**：[具体的交付物]
**成功标准**：[可测试的产出]
**测试**：[具体的测试用例]
**状态**：[未开始|进行中|已完成]
```

- 随着进度更新状态。
- 所有阶段完成后删除该文件。

### 2. 实现流程

1.  **理解** - 研究代码库中的现有模式。
2.  **测试** - 先写测试 (红灯)。
3.  **实现** - 用最少的代码让测试通过 (绿灯)。
4.  **重构** - 在测试通过的前提下清理代码。
5.  **提交 (Commit)** - 撰写清晰的提交信息，并链接到规划文件。

### 3. 遇到困难时 (尝试 3 次后)

**重要**：每个问题最多尝试 3 次，然后停下来。

1.  **记录失败的内容**：

    - 你尝试了什么。
    - 具体的错误信息。
    - 你认为失败的原因。

2.  **研究替代方案**：

    - 找出 2-3 个类似的实现。
    - 记录它们使用的不同方法。

3.  **质询基本原则**：

    - 这是一个正确的抽象层级吗？
    - 这个问题可以分解成更小的问题吗？
    - 有没有一个完全更简单的方法？

4.  **从不同角度尝试**：

    - 使用不同的库/框架功能？
    - 采用不同的架构模式？
    - 移除而非增加抽象层？

## 技术标准

### 架构原则

- **组合优于继承** - 使用依赖注入。
- **接口优于单例** - 以便于测试和保证灵活性。
- **显式优于隐式** - 保持清晰的数据流和依赖关系。
- **尽可能测试驱动** - 绝不禁用测试，而是修复它们。

### 代码质量

- **每次提交 (commit) 都必须**：

  - 成功编译。
  - 通过所有现有测试。
  - 包含新功能的测试。
  - 遵循项目的格式化/Linter 规范。

- **提交前**：

  - 运行格式化工具/Linter。
  - 自我审查变更。
  - 确保提交信息解释了"为什么"(why)。

### 错误处理

- 快速失败，并提供描述性信息。
- 包含用于调试的上下文信息。
- 在适当的层级处理错误。
- 绝不静默地处理异常。

## 决策框架

当存在多种有效方法时，应按以下顺序选择：

1.  **可测试性** - 我能轻易地测试它吗？
2.  **可读性** - 6 个月后还有人能看懂吗？
3.  **一致性** - 这是否符合项目的既有模式？
4.  **简洁性** - 这是能解决问题的最简单的方案吗？
5.  **可逆性** - 未来修改的难度有多大？

## 项目集成

### 学习代码库

- 找出 3 个类似的功能/组件。
- 识别出通用的模式和约定。
- 尽可能使用相同的库/工具类。
- 遵循现有的测试模式。

### 工具集

- 使用项目现有的构建系统。
- 使用项目现有的测试框架。
- 使用项目现有的格式化工具/Linter 配置。
- 没有充分的理由，不要引入新工具。

## 质量门禁

### "完成"的定义

- [ ] 已编写测试并全部通过
- [ ] 代码遵循项目约定
- [ ] 没有 Linter/格式化工具的警告
- [ ] 提交信息清晰明确
- [ ] 实现内容与规划相符
- [ ] 没有未关联 issue 编号的 TODO 项

### 测试指南

- 测试行为，而非实现细节。
- 尽可能每个测试只包含一个断言 (assertion)。
- 测试名称应清晰描述测试场景。
- 使用现有的测试工具/辅助函数。
- 测试应具有确定性。

## 重要提醒

**绝不**：

- 使用 `--no-verify` 绕过提交钩子 (commit hooks)。
- 禁用测试而不是修复它们。
- 提交无法编译的代码。
- 做出假设 — 应通过现有代码进行验证。

**务必**：

- 渐进式地提交可工作的代码。
- 随时更新规划文件。
- 从现有的实现中学习。
- 尝试 3 次失败后就停下来重新评估。
